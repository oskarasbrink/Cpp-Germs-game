/*
 * transmit411.asm
 *
 *  Created: 2019-03-01 10:21:24
 *   Author: oskas206
 */ 


	.equ SPEED=$02
	.dseg
	.org SRAM_START
Playerselect : .byte 1
Player1 : .byte 8
Player2 : .byte 8
WHERE_FALL:	.byte 1
What_fall: .byte 1

	.macro JOYSTICK_X
	ldi @0,(1<<adlar)
	out admux,@0

	sbi adcsra,adsc
	sbic adcsra,adsc
	rjmp pc-1
	in @0, ADCH;
	.endmacro


	.macro INCSRAM ; inc byte in SRAM
	ld r16 , @0
	sbrs r16,0
	lsr r16
	st @0 , r16
	.endmacro

	.macro DECSRAM ; dec byte in SRAM
	ld r16 , @0
	sbrs r16,7
	lsl r16
	st @0 , r16
	.endmacro

 .cseg
 jmp start
	.org $00c
jmp timer_interrupt



start:
	 ldi r16, HIGH(RAMEND)
	 out sph,r16
	 ldi r16,LOW(RAMEND)
	 out spl, r16
	 rcall HW_INIT
	rcall usart_init
	call timer_init
	call adc_init
	sei




end:

	rjmp end



Joystick: ; borde funka tror vi
	push r19
	push r16
	push zh
	push zl
	
	lds r16,playerselect
	
	ldi zh,high(player1)
	ldi zl,low(player1)

	sbrc r16,0
	subi zl,-8

	joystick_x r19
	andi r19,$F0

	cpi r19,$F0
	brne INTE_Fram
	decsram Z
	INte_Fram:
	cpi r19,$00
	brne inte_bak
	incsram Z
	inte_bak:


	pop zl
	pop zh
	pop r16
	pop r19

	ret

Update_player:

	push r16
	push r17

	lds r16, SRAM_START
	ldi r17,$01
	eor r16,r17
	sts SRAM_START,r16

	ldi r17,8

	sbrs r16,0
	sts player1,r17

	sbrc r16,0 
	sts player2,r17

	pop r17
	pop r16

	ret




DELAY:
ldi     r19,$FF   ; Decimal bas
delayYttreLoop:
ldi     r17,$FF
delayInreLoop:
dec     r17
brne    delayInreLoop
dec     r19                    ;1 millisekund
brne    delayYttreLoop

	ret


USART_Transmit:
	
	; Wait for empty transmit buffer
	sbis UCSRA,UDRE
	rjmp USART_Transmit

	//ldi r16,$05 
	out UDR,r16
	
	ret


USART_Init:

	clr r17
	ldi r16,12
	out UBRRH, r17
	out UBRRL, r16

	ldi r16, (0<<RXEN)|(1<<TXEN)
	out UCSRB,r16

	ldi r16, (1<<URSEL)|(1<<USBS)|(3<<UCSZ0)
	out UCSRC,r16
	
	ret


temp_load:
	ldi ZH,High(player1)
	ldi ZL,Low(player1)
	
	lds r16,playerselect

	ldi r17,8
	sbrs r16,0
	sts player1,r17

	sbrc r16,0 
	sts player2,r17
	
	ldi r16,low(player1)
	sts where_fall,r16

	
	
	ret



HW_INIT:
		
	ldi ZH,High(Playerselect)
	ldi ZL,Low(Playerselect)
	ldi r16,17
	clr r17
	inteklar:
	st Z+,r17
	dec r16
	brne inteklar

	rcall temp_load

	ldi r16,$F2
	out ddra, r16
	out ddrb, r16
	ldi r16, (1<<PD1)|(0<<PD7)
	out ddrd,r16

	ret

adc_init:

	
	ldi r16,(1<<adlar);	adc0 ingång vald
	out admux,r16;			adlar=1, left adjust result.

	ldi r16,(1<<aden);	aden=enable ((PRESCALE<<adps))? adps (adprescaler) sätts i varje fall i acsra (adc statusregister) (s.213 i PDF).
	out adcsra,r16;	slår på strömmen till ad-hardwarewere

	ret

timer_init:

	clr r16
	out TCCR1A,r16
	ldi r16, (1<<CS12)|(1<<CS10)|(1<<wgm12)
	out TCCR1B,r16
	
	ldi r16,SPEED/// r16
	out ocr1AH,r16
	ldi r16,$00
	out ocr1AL,r16

	
	ldi r16,(0<<TOIE0)|(0<<TOIE1)|(1<<ocie1a)
	out TIMSK,r16


	ret



check_legal:
	push zh
	push zl
	push r16
	push r17

	ldi zh,HIGH(PLAYER1)
	ldi ZL,low(player1)

	lds r16, playerselect
	sbrc r16,0
	subi ZL,-8

	lds r17, (player1)+1
	lds r16, (player2)+1
	or r17,r16
	ld r16,z
	and r16,r17
	cpi r16,0
	brne not_legal
	rjmp legal

not_legal:
	ldi r17,$02
	lds r16,PLAYERSELECT
	or r16,r17
	sts playerselect,r16	


legal:

	pop r17
	pop r16
	pop zl
	pop zh

	ret


set_fall:
push r17
push r16
	
	call check_legal
	
	ldi r17,$02
	lds r16,PLAYERSELECT
	eor r16,r17
	sts playerselect,r16	
	lds r17,player2

	sbrs r16,0
	lds r17,player1

	sts what_fall,r17

pop r16
pop r17
ret

timer_interrupt:
	PUSH R16
	in r16,sreg
	push r16
	push r17
	push zl
	push zh

	clr r16
	out TCCR1B,r16
	
	lds r16,PLAYERSELECT
	sbrc r16,1
	rjmp slapp

	sbis PIND,7
	rcall set_fall

	lds r16,PLAYERSELECT
	sbrs r16,1
	rjmp inte_slapp


SLAPP:
	call fall_animation
	
	lds r16,playerselect
	sbrs r16,1
	call update_player
	rjmp send_field
inte_slapp:
	

	ldi zh,HIGH(PLAYER1)
	ldi ZL,low(player1)

	lds r16, playerselect
	sbrs r16,0
	subi ZL,-8
	
	call joystick
	
send_field:

	ldi ZH,HIGH(player1)
	ldi ZL,LOW(player1)
	ldi r17,16
send_loop:

	ld r16,z+

	rcall usart_transmit
	dec r17
	brne send_loop




	ldi r16, (1<<CS12)|(1<<CS10)|(1<<wgm12)
	out TCCR1B,r16



	pop zh
	pop zl
	pop r17
	pop r16
	out sreg,r16
	pop r16
	reti



fall_animation:
	push zh
	push zl
	push r16
	push r18
	push r19
	push r20
	push r21
	push r22
	push r23

	lds r16,playerselect
	ldi ZH,High(Player1)
	lds ZL,where_fall
	lds r16,what_fall

falling:
	
	ldd r18,Z+1
	ldd r19,Z+9
	or r18,r19 ; kombinera båda spelplanernas rad under
	mov r19,r18 ; spara rad under i temp, 2 kopior av raden únder

	or r18,r16 ; or:a undre med övre

	cp r19,r18
	breq landed

	lds r20,playerselect

	sbrs r20,0
	rjmp spelare1

	;player2
	ldd r21,Z+8 ; ladda rad som ska falla
	ldd r22,z+9 ; ladda rad under
	mov r23,r22 ; spara rad under i temp
	or r22,r16  ; or:a rad under för att få ny rad under
	and r21,r19 ; uppdatera rad över
	std z+8,r21
	std z+9,r22

	rjmp hejsvejs

spelare1:
	ld r21,Z ; ladda rad som ska falla
	ldd r22,z+1 ; ladda rad under
	mov r23,r22 ; spara rad under i temp
	or r22,r16  ; or:a rad under för att få ny rad under
	and r21,r19 ; updatera rad över
	st z,r21
	std z+1,r22

hejsvejs:
	
	subi zl,-1
	sts where_fall,zl

	cpi ZL,LOW(PLAYER1)+7
	BREQ landed
	cpi ZL,LOW(player2)+7
	breq landed
	rjmp ended

landed:
	
	call check_win

	;lds r16,what_fall
	;cpi r16,$ff
	;breq not_win

	;call winn

not_win:
	ldi r16,low(player1)
	sts where_fall,r16
	lds r16,playerselect
	andi r16,$FD
	sts playerselect,r16


ended:
	pop r23
	pop r22
	pop r21
	pop r20
	pop r19
	pop r18
	pop r16
	pop zl
	pop zh

	ret


check_win:

	push r16
	push r17
	push r18
	push zh
	push zl

	lds r16,where_fall ; y

	ldi zh,high(player1)
	lds zl,where_fall

	lds r18,playerselect
	sbrc r18,0
	subi zl,-8

	ld r16,z
	ldi r18,8
	clr r17
lopan:

	sbrs r16,0
	clr r17

	inc r17
	cpi r17,5
	breq winn
	
	lsr r16

	dec r18
	brne lopan

not_winn:
	
	pop zl
	pop zh
	pop r18
	pop r17
	pop r16

	ret


winn:

jmp start


	ret
